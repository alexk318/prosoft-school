# prosoft-school

Решенные задачи:

1. [Unary](https://www.codingame.com/ide/puzzle/unary) <br />
Самое важное в задаче - правильно определить серию элементов, что делается сравнением с предыдущим элементом.
Далее в соотвествии с числом выводим правильную комбинацию нулей.

2. [Horse-racing Duals](https://www.codingame.com/ide/puzzle/horse-racing-duals) <br />
При большом числе элементов решение задачи может быть слишком долгим. Поэтому необходимо подобрать правильный алгоритм.
Минимальная разница будет в одной из последовательных пар в отсортированном массиве.

3. [Temperatures](https://www.codingame.com/ide/puzzle/temperatures) <br />

4. [Logic gates](https://www.codingame.com/ide/puzzle/logic-gates) <br />
Реализуем отдельно логические функции по таблицам истинности.

5. [MIME Type](https://www.codingame.com/ide/puzzle/mime-type) <br />
Вся задача состоит в разделении строки разделенной на две точки. Оптимально это делается поиском последней точки - в строке может быть несколько точек.

6. [Defibrillators](https://www.codingame.com/ide/puzzle/defibrillators) <br />
Для удобства организуем класс дефибриллятора с методом вычисления расстояния. Тогда самой программе остается только найти наименьшее расстояние.

7. [Conway Sequence](https://www.codingame.com/ide/puzzle/conway-sequence) <br />
Самое сложное в задаче - это определять двухзначные числа в строке. Для этого между числами сохраняются пробелы. По ходу программы по числам проходит курсор, а пробелы
служает точкой проверки прочитанной информации. Записанные числа делятся на seekeed (Последнее прочитанное число) и current (Текущие данные курсора). Вся логика состоит в сравнении seekeed и current. Оказывается важным понимать момент окончания строки, для чего в конец добавляется ноль.

8. [There is no Spoon - Episode 1](https://www.codingame.com/ide/puzzle/there-is-no-spoon-episode-1) <br />
В циклах проходимся по горизонталям и вертикалям при этом убеждаясь, что клетка не пустая.

9. [Death First Search - Episode 1](https://www.codingame.com/ide/puzzle/death-first-search-episode-1) <br />
Неориентированный граф организуется отображением, где смежные вершины указывают друг на друга. Вся задача состоит в использовании поиска в ширину.
Смежные с агентом вершины добавляются в очередь. При этом очередь хранит массивы - кроме самой смежной вершины, оказывается важно хранить от какой вершины идет добавление.
Уже проверенные вершины добавляются в динамический массив checked. Разрыв нужной ветви осуществляется удалением обоих вершин в отображении.

10. [Dwarfs standing on the shoulders of giants](https://www.codingame.com/ide/puzzle/dwarfs-standing-on-the-shoulders-of-giants) <br />
Предлагаемые ориентированные графы - деревья. Поэтому логично использовать поиск в глубину. Задача сводится к двум этапам: 1. Найти корень(корни) дерева; 2. Применить поиск в глубину. 
Первый шаг решается исходя из того, что корни - элементы у которых нет ключей и они не окажутся в правой части отображения. Поэтому корни - разница множества всех элементов и множества значений отображения. Являясь коллекцииями без повторяющихся элементов, множества тут очень удобно использовать.
Второй шаг заключается в использовании рекурсивной функции. Передавая переменную max_step по ссылке, получается просто выудить из рекурсивной функции самый глубокий путь.
